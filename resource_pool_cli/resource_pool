#!/usr/bin/python3

import click
import random
import string
import sys
import os
import subprocess
import json
import time
import fileinput
from prettytable import PrettyTable


ANSIBLE_DIR = "/etc/ansible"

def show_pool_info(rp_name):
    pool_core_count = 0
    pool_mem_amount = 0
    rp_dir = "{}/{}".format(ANSIBLE_DIR, rp_name)

    cmd = "ansible all -i {}/hosts -m gather_facts --tree {}".format(rp_dir, rp_dir)
    process = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out = process.communicate()[0]

    for file in os.listdir(rp_dir):
        if not file.startswith('1'):
            continue

        with open("{}/{}".format(rp_dir, file), 'r') as myfile:
            data = myfile.read()
        facts = json.loads(data)

        if 'msg' in facts:
            if facts['msg'].startswith('SSH Error'):
                os.remove("{}/{}".format(rp_dir, file))
                continue

        this_server_core_count = facts['ansible_facts']['ansible_processor_cores']
        this_server_mem_amount = facts['ansible_facts']['ansible_memtotal_mb'] / 1024.0
        pool_core_count = pool_core_count + this_server_core_count
        pool_mem_amount = pool_mem_amount + this_server_mem_amount
        os.remove("{}/{}".format(rp_dir, file))

    hosts_file = "{}/{}/hosts".format(ANSIBLE_DIR, rp_name)
    hosts = open(hosts_file)
    host_lines = hosts.readlines()
    master_server = host_lines[1].strip() ##NEED TO MAKE THIS DYNAMIC AND NOT DEPEND ON LINE 2 IN FILE

    output_table = PrettyTable(['Pool Name', rp_name])
    output_table.add_row(['Cluster Master', master_server])
    output_table.add_row(['CPU Cores', pool_core_count])
    output_table.add_row(['GB of RAM', round(pool_mem_amount, 2)])
    click.echo(output_table)    


@click.group(context_settings={"help_option_names": ["-h", "--help"]})
def cli():
    pass


@cli.command()
def list():
    for file in os.listdir(ANSIBLE_DIR):
        if not os.path.isdir(file):
            continue
        show_pool_info(file)


@cli.command()
@click.argument("rp_name")
def show(rp_name):
    show_pool_info(rp_name)

@cli.command()
@click.argument("rp_name")
#@click.option("--cores", "-c", type=int)
#@click.option("--memory", "-m", type=int)
#def create(rp_name, cores, memory):
def create(rp_name):
    click.echo("Running playbook...")
    #RIGHT HERE, REALLY NEED TO MOVE FILES FROM FLEET LIST INTO HERE
    #NEED DATA STRUCTURE TO HELP DETERMINE HOW MANY SERVER NEED TO FULFILL CPU/RAM NEEDS
    hosts_file = "{}/{}/hosts".format(ANSIBLE_DIR, rp_name)
    cmd = "ansible-playbook -i {} /etc/ansible/k8s".format(hosts_file)
    hosts = open(hosts_file)
    host_lines = hosts.readlines()
    master_server = host_lines[1].strip() ##NEED TO MAKE THIS DYNAMIC AND NOT DEPEND ON LINE 2 IN FILE
    process = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    kubeadm_init_output = str(process.communicate()[0])
    token = kubeadm_init_output.split('--token')[1].split()[0]
    cert_hash = kubeadm_init_output.split('--discovery-token-ca-cert-hash')[1].split()[0]
 
    join_file = "/etc/ansible/{}/join".format(rp_name)
    with fileinput.FileInput(join_file, inplace=True) as file:
        for line in file:
            print(line.replace("MASTERIP", master_server), end='')
    
    with fileinput.FileInput(join_file, inplace=True) as file:
        for line in file:
            print(line.replace("CREDS", "--token {} --discovery-token-ca-cert-hash {}".format(token, cert_hash)), end='')

    cmd = "ansible-playbook {} -i {}".format(join_file, hosts_file)
    process = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    join_output = str(process.communicate()[0])
'''
    if not cores or not memory:
        click.echo("You must specify cores and memory")
    else:
        lines_in_fleet_file = len(open(FLEET_LIST).readlines())
        if lines_in_fleet_file < 4:
            click.echo("There are not enough servers available to create a new resource pool.")
            sys.exit()

        # This whole part will just end up calling show()
        #FOR FILE IN DIR ()
        thefile = "/tmp/facts/172.31.90.199" #This should be list of every host file
        with open(thefile, 'r') as myfile:
            data=myfile.read()
        facts = json.loads(data)
        core_count_fleet = facts['ansible_facts']['ansible_processor_cores']
        mem_amount_fleet = facts['ansible_facts']['ansible_memtotal_mb']

        if core_count_fleet < cores or mem_amount_fleet < memory:
            click.echo("There are not enough resources available to create a new resource pool.")
            sys.exit()

        #run k8s playbook on this host set

        click.echo("Creating RP with {} cores and {}GB".format(cores, memory))
'''

@cli.command()
@click.option("--cores", "-c", type=int)
@click.option("--memory", "-m", type=int)
def resize(cores, memory):
    if not cores and not memory:
        click.echo("You must specify cores or memory")
    else:
        click.echo("Resizing RP with {} cores and {}GB".format(cores, memory))


@cli.command()
@click.argument("rp_name")
def destroy(rp_name):
    click.echo(
        "You are attempting to destroy the {} resource pool.\nThis cannot be undone".format(
            rp_name
        )
    )
    validation_string = randomString(5)
    click.echo(
        "To confirm this action, please type out the following string: {}".format(
            validation_string
        )
    )

    user_validation_string = input("Enter string : ")

    if user_validation_string == validation_string:
        hosts_file = "{}/{}/hosts".format(ANSIBLE_DIR, rp_name)
        cmd = "ansible-playbook /etc/ansible/destroy -i {}".format(hosts_file)
        process = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        destroy_output = str(process.communicate()[0])
        print(destroy_output)
    else:
        click.echo("Your input did not match the validation string")


def randomString(stringLength=10):
    """Generate a random string of fixed length """
    letters = string.ascii_lowercase
    return "".join(random.choice(letters) for i in range(stringLength))


if __name__ == "__main__":
    cli()
